% Author: Kurt O'Hearn
% Author: Nicholas Olesak
% Date: April 15, 2013
% Class: CIS 343-02
% Purpose: Progamming Language Survey Term Paper on Haskell
\documentclass[titlepage,12pt]{article}

\usepackage{appendix}
\usepackage{minted}

% aliases
\newcommand{\be}{\begin{enumerate}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\ei}{\end{itemize}}

\title{Programming Language Survey Paper on Haskell}
\author{
        Kurt O'Hearn\\
        Nicholas Olesak\\
}
\date{\today}


\begin{document}

\maketitle 
\setcounter{tocdepth}{3}
\tableofcontents \newpage


\section{Introduction}
This paper provides an overview of the Haskell programming language.  The sections are outlined as follows:
section 1 describes the background surrounding Haskell, including its connections to functional programming,
and its usage today.  Section 2 provides a survey of many of the data and control constructs native to Haskell.
Section 3 presents a brief look at several extensions beyond the Haskell core.

\subsection{Origin and History}

In the early 1930s, Alonzo Church formulated a mathematical abstraction known as lambda calculus, which involves the description 
and evaluation of functions in mathematics. Lambda calculus became the foundation for functional programming~\cite{haskell-wiki}. 
However, as numerous functional languages began to develop, many exhibited similar expressiveness and semantics.  This led to
desire for a standard functional language to aid the spread of functional programming. A meeting was held 
in 1987 at a Functional Programming Languages and Computer Architecture conference to address this need~\cite{hudak-hist}. The meeting 
resulted in the formation of a committee to design a standard functional language. In 1990, the committee performed 
a consolidation of the aspects of existing functional programming languages into an open standard, common language to be used for 
functional programming research: Haskell~\cite{hudak-con}.

Haskell is named after Haskell Curry, a logician whose work greatly contributed to functional programming. The logo of Haskell, lambda,
symbolize lambda calculus as its foundation. Today, Haskell is widely used in many different aspects 
of computing. From AT\&T's automated processing of abuse complaints in its network security division to the National 
Radio Astronomy Observatory’s implementation of core science algorithms, Haskell can be found in many aspects of 
modern industry~\cite{haskell-wiki}. 

\subsection{Functional Programming Paradigm}

The core of Haskell is a pure functional language, which means that its functions possess no concept of memory locations or other
hardware-related statefullness. Every function acts independently of other functions and does not change the state of anything outside 
its scope. This concept is referred to as having no ``side-effects,'' and this affords Haskell a certain simplicity in design
and implementation, as well as lends itself to other means such as optimization toward parallel processing. In addition,
functions do not have to be declared in a particular order since they all exist independently of one another. 

\subsection{Application Domains}

Haskell is most commonly used for the development of substantial software systems. The language is designed to produce
productivity from programmers in fewer lines of code. In addition, having no side-effects leads to fewer errors.
These features are very important in the development of large software systems, and Haskell is an ideal choice. 

Other popular uses of Haskell include the development of domain specific languages, web startups, mathematics, 
hardware design firms, finance, and aerospace and defense. Haskell's use in commercial industry ranges from AT\&T's 
automated processing of abuse complaints to the National Radio Astronomy Observatory’s implementation of core science algorithms.


\section{Data and Control Abstractions}
This section presents a tutorial-style introduction to the core concepts of
the Haskell language~\cite{learnyouahaskell}.  Data and control abstractions are covered
in the proceeding sections.  To begin with, the obligatory ``Hello, World!'' program is Haskell
is presented below.

\begin{minted}{haskell}
module Main where

main :: IO ()
main = putStrLn "Hello World!"
\end{minted}

\subsection{Data Abstractions}
Haskell supports a very rich, strong, static type system for programmers.  As Haskell is
a compiled language, with the Glasgow Haskell Compiler (GHC) being the most common implementation,
most of the type checking is done and enforced at compile time.

\subsubsection{Data Types}

Haskell includes many of the data types that are standard in most languages, such as Integers, Floats, Characters, and Boolean values. 

\begin{minted}{haskell}
let x = 2
let pi = 3.14
let c = 'c'
let isHaskellAwesome = True
\end{minted}

Two more foundational data types in Haskell are lists and tuples. Lists are the most used data type due to their expendability 
and the wide range of functions that are available to manipulate them. They can easily be created, traversed, concatenated, 
reversed, sorted, and more with standard, built-in functions. Lists, however, are homogeneous, ordered collections of
similar data types. Tuples, on the other hand, heterogeneous collections. Tuples are most useful when the types and exact number of 
values to be combined are known. Like lists, there is a wide array of built-in functions for tuples including, for instance,
a function for zipping two lists into one by joining matching elements into tuples. Simple yet elegant code can be written by
employing lists, tuples, and the other various other data types in Haskell.

\begin{minted}{haskell}
let evens = [2, 4, 6, 8, 10]	-- list
let t = (3.14, 'pi')		-- tuple
\end{minted}

Haskell also allows the definition Strings, which are represented by surrounding text with double quotes. Strings, however, 
are not their own data type. Although string literals can be initialized using the double quote syntax, the compiler converts the 
string into a list of characters at compile time. The use of the String notation is simply syntatic sugar for programmers. 
It also helps increase the readability of code. In the following example, the data is stored in the representation of 
str1: a list of characters. However, Haskell allows the definition of a string using double quotes, as seen in \texttt{str2}, 
which is much more understandable.

\begin{minted}{haskell}
let str1 = ['H','a','s','k','e','l','l','!']
let str2 = "Haskell!"   -- shorthand for str1
\end{minted}

In addition to these basic data types, Haskell also offers type variables. Type variables are variables whose type has 
not been explicitly declared; rather, they can be any type.  By defining a function without declaring data types, the 
variables in the function can be used as any type thereby enabling polymorphic behaviors. In the following example, the 
function can handle a list of any type because its uses a type variable. 

\begin{minted}{haskell}
lastTwo :: [a] -> [a]
lastTwo a = [a !! ((length a) - 2), a !! ((length a) - 1)]
\end{minted}

\subsubsection{Type Checking}
Type checking in Haskell is performed statically at compile time. Haskell uses type-declarations for functions, in 
which the types of parameters and return values are explicitly defined. Any use of a function in which parameters 
do not meet the defined function type is flagged by the compiler, and compilation will be aborted. In addition, 
use type inferencing by context. The type system in Haskell deduces obvious types and makes them concrete. In the 
following example, although the type of myNum is unknown at compile time, the compiler infers that the Int type 
is desired because myNum is added to an Int. 

\begin{minted}{haskell}
let myStr = "2" 
let myNum2 = (read myStr) + 2
\end{minted}

If the context does not suggest the type, as in the example below, then an exception will result because the 
compiler cannot infer what the type is going to be and is unable to handle it. 

\begin{minted}{haskell}
let myStr = "2" 
let myNum = read myStr
\end{minted}

Haskell uses typeclasses to categorize the type system. Typeclasses define the behavior of a general type. 
A type must support the definition of its typeclass, but may also be more specific. For example, all of the 
operators in Haskell are categorized under the Eq typeclass. Other examples of typeclasses in Haskell include Ord, 
Show, Read, Enum, Num, Integral, and Floating. Typeclasses can be used to allow multiple types to be passed to a 
function. In the following example, the function declares its typeclass as Integral. Therefore, the function will 
allow accept Int or Integer types as parameters. 

\begin{minted}{haskell}
incrementMe :: (Integral a) => a -> a
incrementMe a = a + 1
\end{minted}

\subsection{Control Abstractions}
\subsubsection{Expressions}

Function definitions in Haskell are very simple and straightforward. A function consists of the function name, 
parameters, and an expression. The return value of the function is the evaluation of the expression, which 
uses the parameters. The naming standard for functions in Haskell is to use camel case. All functions in 
Haskell must take at least one parameter and must return only one value. They can, however, be passed 
multiple parameters. Functions are usually called with prefix notation; that is, the name of the function is 
followed by its arguments. It is possible, however, to call functions using infix notation, which is sometimes appropriate 
if the function takes two arguments. Additionally, all operators are called using infix notation. The following example 
demonstrates how a function can be called using infix notation. 

\begin{minted}{haskell}
let evens = [2, 4, 6, 8]
print (elem 2 evens)   -- prefix notation
print (2 `elem` evens) -- infix  notation
\end{minted}

The data type for each parameter of a function can be explicitly declared by using the \texttt{::} symbol, which is 
read as ``has a type of.''  The types of the parameters can be listed in order, and the last type in the list 
is the return type. The following function is called \texttt{greet}.

It takes in a string and returns a string. The string is passed in as the variable \texttt{name}. Everything that follows 
the equal sign is the expression, and the evaluation of this expression is the return value. 

\begin{minted}{haskell}
greet :: String -> String
greet name = "Hello, " ++ name ++ "!"
\end{minted}

Bindings in Haskell can be created in two different ways. The first is using \texttt{where} bindings. \texttt{where} bindings allow 
the definition of a function inside another function. The scope of the function declared by a \texttt{where} is locally bound 
by the function that created it. Functions outside of the declaring function cannot call the function declared inside 
the \texttt{where}. Additionally, \texttt{where} bindings can be nested; that is, a function declared inside a \texttt{where} can declare
its own helper functions inside a \texttt{where}. \texttt{where} bindings can also span across guards, which will be covered shortly. 

In the following example, the function \texttt{rectPrismVol} declares two functions: \texttt{faceArea} and \texttt{baseArea}. Only the 
\texttt{rectPrismVol} function is allowed to call these functions because they are locally bound. 

\begin{minted}{haskell}
rectPrismVol :: (Num a) -> a -> a -> a -> a
rectPrismVol length width height = 4 * (faceArea length width)
    + 2 * (baseArea length height)
where   faceArea l w = l * w
        baseArea = l * h
\end{minted}

The second type of binding available in Haskell is done using \texttt{let} bindings. \texttt{let} bindings allow the declaration of 
variables that are expressions themselves and are locally bound.  \texttt{let} bindings are often used for pattern matching. 
The syntax of \texttt{let} bindings involved declaring the bindings inside a \texttt{let} declaration, followed by defining an 
expression inside an \texttt{in} declaration. The \texttt{let} and \texttt{in} statements must be aligned in the same column. 

\begin{minted}{haskell}
myExp =
    let e = 2.7182
    in  e ** x
\end{minted}

The difference between \texttt{let} and \texttt{where} bindings is that \texttt{let} bindings are expressions themselves, whereas 
\texttt{where} bindings are just syntactic constructs. Additionally, unlike \texttt{where} bindings, \texttt{let} bindings cannot 
span across guards.

\subsubsection{Operators and Precedence}

Operators in Haskell are typically represented with symbols. Some of the basic operators in Haskell include addition, 
subtraction, multiplication, divison, exponentiation, concatenation, and equality operators and logic operators. The 
precedence of operators conform to the standard orders used in mathematics: exponentiation is highest, followed by 
muliplication and visision, with addition and subtraction with the lowest precedence.  

All operators in Haskell are binary, and they are usually called using infix notation; that is, the operator is 
placed between its two arguments. Although it is possible to use operators in prefix notation, it is customary to use 
infix notation to increase readability. This contrasts from most functional programming languages. 

\begin{minted}{haskell}
print (2 + 5)    -- infix notation is the standard
print ((+) 2 5)  -- prefix notation is still possible
\end{minted}

Operators in Haskell can also be overloaded. The number and type of arguments as well as the expression can be modified. 

\begin{minted}{haskell}
(*) :: (Num a) => a -> a -> a
(*) a b = a + a + a + a
print (2 * 3)   -- yields 8 rather than 6
\end{minted}

\subsubsection{Selection Constructs}

Selection constructs in Haskell consist of if-else statements, guards, pattern matching, and case expressions. 

If-else statements in Haskell conform to the traditional syntax of the if-else selection construct. The only notable 
difference is that Haskell requires that every conditional is followed by a then expression and an else expression. 
The compiler will prevent compilation for any if conditional that does not also have then and else statements because 
without them it would be possible for an input to cause a function not to have a return value, which Haskell does not allow.

\begin{minted}{haskell}
guessGame :: Int -> String
guessGame x = if x == 42
    then "You have a deep understanding of life."
    else "You need to think more about life."
\end{minted}

If-else statements are not used in Haskell as often as they are in imperative languages because Haskell offers a feature 
known as guards, which are fundamentally equivalent to if-else statements except they are much more easily understood, 
work with multiple conditions, and blend well with pattern matching. Guards are created using pipes in the 
expression of a function and consist of a conditional, which must evaluate to true or false, and an expression. 
An equals sign separates the conditional from the expression. Arguments are checked against the guards in 
sequential order. If the condition is true, then the expression for that guard is evaluated and returned. 
If the condition is false, then the next guard condition is evaluated, and this pattern continues until the 
`otherwise' guard is reached, which catches all input that did not match any guard previous conditions. The 
following function has three guards, each following a pipe. A notable aspect of this function is that if the 
input is value is greater than 100,000 it will cause the first guard condition to be true and will evaluate the 
first guard expression even though the input would also be true for the second guard. This is because the guards are 
checked in order, so the second guard is never checked because the first guard is true and the return value is 
determined from it. The otherwise guard is placed at the bottom to catch any value that does not cause the first two guards to be true. 

\begin{minted}{haskell}
let balance = 200
assessWorth :: Int -> String
assessWorth =
    | balance > 100000 = "You're rich!"
    | balance > 100 = "You're rich by student standards!"
    | otherwise = "Need a loan, friend?"
\end{minted}

Another selection construct in Haskell is pattern matching. Pattern matching is simply a way to have a 
function perform different actions based on its input. Pattern matching is done by defining a function multiple times in 
succession using patterns in place of parameters.  When the function is called, its arguments are checked against all patterns,
starting with the first and proceeding accordingly.  If no match is made, an exception is raised.
A default match can be speficied by listing `plain' variables as function parameters.

In the following example, an input of ``Haskell'' will produce the first expression, ``Clojure'' will skip the first 
and produce the second, and any other input will produce the third. Note that the third and final expression does 
not have a pattern to match, but instead uses a variable to catch all other input. 

\begin{minted}{haskell}
favoriteLang :: String -> String
favoriteLang "Haskell" = "You have refined taste, my friend."
favoriteLang "Clojure" = 
    "The wise do not build a house on unsturdy ground."
favoriteLang lang = lang ++ 
    " is a fine choice, but you should give Haskell a spin."
\end{minted}

The final selection construct in Haskell is case expressions. Case expressions evaluate expressions based on 
the values of a parameter. They are similar to case constructs in imperative languages, except they can also pattern 
match the input. Note that this is exactly how pattern matching parameters in function definitions works. In 
fact, pattern matching parameters is simply an easier way to write case expressions, and the two are interchangeable. 

The following function demonstrates how to evaluate a specific expression that depends on which pattern 
an argument matches by using the \texttt{case} construct. Note that if this function were written using the 
pattern matching technique it would work exactly the same way. 

\begin{minted}{haskell}
favoriteMathSymbol :: String -> String
favoriteMathSymbol x = case x of
    "Pi" -> "Geometry is your mind's eye."
    "e" -> "May the calculus forever be with you."
    "Epsilon" -> "I think I am within the limit, "
        ++ "therefore, I am within the limit."
    x = "You have much to learn of the maths."
\end{minted}

\subsubsection{Iterative Constructs}
\bi
    \item List comprehensions
\begin{minted}{haskell}
filterModThree :: [Int] -> [Int]
filterModThree xs = [x | x <- xs, x `mod` 3 == 0]
\end{minted}
    \item Map/fold
\begin{minted}{haskell}
sumSquares :: (Num a) => [a] -> a
sumSquares xs = foldr1 (+) (map (**2) xs)
\end{minted}
    \item Recursion
\begin{minted}{haskell}
countdown :: Int -> String
countdown 0 = "Blast-off!"
countdown x = (show x) ++ "...\n" ++ countdown (x-1)
\end{minted}
\ei

\subsubsection{Functions}
\bi
    \item Definition/use
    \item Parameter passing techniques
\ei

\subsubsection{Scoping}
In Haskell, static scoping is employed.  As such, bindings are localized
to the function in which they were defined or passed.

\subsubsection{Modules}
\begin{minted}{haskell}
module myMod 
( 
addTwo,
addThree,
addFour
) where

addTwo :: (Num a) => a -> a
addTwo x = x + 2

addThree :: (Num a) => a -> a
addThree x = x + 3

addFour :: (Num a) => a -> a
addFour x = x + 4
\end{minted}
\subsubsection{Exception Handling}



\section{Advanced Topics}
Beyond the basic data and control structures discussed to this point,
Haskell contains a wide array of constructs, extension modules, and
and other features.  This section considers the following advanced
topics: inheritance, concurrency, and runtime type checking.

\subsection{Inheritance}

Inheritance in Haskell can be achieved through class extension, which involves defining a class as a subclass 
of some other class. The subclass then inherits all of the operations in the superclass. A benefit to class 
extension is shorter contexts: a type expression for a function that uses operations from both the subclass 
and the superclass only has to use the context of the subclass. Additionally, methods for subclass 
operations can assume the existence of methods for superclass operations.

The following class definition of the \texttt{Ord} typeclass inherits all of the operations in the \texttt{Eq} typeclass but
also obtains comparison operators as well as the \texttt{maximum} and \texttt{minimum} functions.

\begin{minted}{haskell}
class  (Eq a) => Ord a  where
    (<), (<=), (>=), (>)  :: a -> a -> Bool
    max, min              :: a -> a -> a
\end{minted}

\subsection{Concurrency Support}


\subsection{Introspection and Reflection}

As mentioned previously, Haskell posesses a strong static type system
implented at compile time. As such, the Haskell '98 language definition
does not provide support for runtime type examination or manipulation
(i.e., introspection and reflection, respectively).  However, effors have been
made toward adding support similar to these features:
\bi
    \item Scrap your boilerplate: generic programming~\cite{haskell-syb}
    \item Template Haskell: an extension module for compile-time metaprogramming~\cite{haskell-th}
\ei


\newpage
\begin{appendices}
\section{Project Implementation in Haskell}
\inputminted{haskell}{src/InfixPostfix.hs}
\newpage
\inputminted{haskell}{src/InfixPostfixTest.hs}
\end{appendices}


\newpage
\bibliographystyle{abbrv}
\bibliography{paper}


\end{document}
