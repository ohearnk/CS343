% Author: Kurt O'Hearn
% Author: Nicholas Olesak
% Date: April 15, 2013
% Class: CIS 343-02
% Purpose: Progamming Language Survey Term Paper on Haskell
\documentclass[titlepage,12pt]{article}

\usepackage{minted}

% aliases
\newcommand{\be}{\begin{enumerate}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\ei}{\end{itemize}}

\title{Programming Language Survey Paper on Haskell}
\author{
        Kurt O'Hearn\\
        Nicholas Olesak\\
}
\date{\today}


\begin{document}

\maketitle 
\setcounter{tocdepth}{3}
\tableofcontents \newpage

\section{Introduction}
This paper provides an overview of the Haskell programming language.

\subsection{Origin and History}

In the early 1930s, Alonzo Church formulated a mathematical abstraction known as lambda calculus, which involves the description and evaluation of functions in mathematics (Haskell). Lambda calculus became the foundation for functional programming (``Haskell''). However, as numerous functional languages began to develop, all of which were similar in expressiveness and semantics, there became the need for a standard functional language to aid the spread of functional programming (Hudak 1). A meeting was held in 1987 at a Functional Programming Languages and Computer Architecture conference to address this need (Hudak 1). The meeting resulted in the formation of a committee to design a standard functional language. In 1990, the committee produced their result: a consolidation of existing functional programming languages into an open standard, common language to be used for functional programming research: Haskell (Hudak 3).

Haskell is named after Haskell Curry, a logician whose work greatly contributed to functional programming. It has a lambda as its logo to symbolize lambda calculus as its foundation. Today, Haskell is widely used in many different aspects of computing. From AT\&T's automated processing of abuse complaints in its network security division to the National Radio Astronomy Observatoryâ€™s implementation of core science algorithms, Haskell can be found in many aspects of modern industry (``Haskell''). 

\subsection{Functional Programming Paradigm}

Haskell is a pure functional language, which means that its functions cannot change values, but rather only accept and return values. Every function acts independently of other functions and does not change the state of anything outside of its scope. This is referred to as having no "side-effects," and it allows Haskell to be exceptionally optimized as well as to permit parallel processing. In addition, functions do not have to be declared in a particular order since they all exist independently of one another. 

\subsection{Application Domains}


[TODO]~\cite{learnyouahaskell}
\begin{minted}{haskell}
module Main where
import Data.List

main :: IO ()
main = putStrLn "Hello World!" >> test

test = do 
    print 123
\end{minted}

\section{Data and Control Abstractions}


\subsection{Data Abstractions}
\subsubsection{Data Types}

Haskell includes many of the data types that are standard in most languages, such as Integers, Floats, Characters, and Boolean values. 

 

\begin{minted}{haskell}
let x = 2
let pi = 3.14
let c = 'c'
let isHaskellAwesome = true
\end{minted}

Two more essential data types in Haskell are lists and tuples. Lists are the most used data type due to their expendability and the wide range of functions that are available to manipulate them. They can easily be created, traversed, concatenated, reversed, sorted, and more with standard, built-in functions. Lists, however, are homogeneous and can only contain elements of the same data type. Tuples, on the other hand, can be heterogeneous. They are useful when the types and exact number of values to be combined are known. Like lists, tuples also comes with a surplus of built-in functions, one of which is the ability to zip two lists into one by joining matching elements into pairs. Simple yet elegant code can be written which combines the attributes of lists, tuples, and the other various other data types in Haskell.

\begin{minted}{haskell}
let evens = [2, 4, 6, 8, 10]	-- list
let t = (3.14, 'pi')		-- tuple
\end{minted}

Haskell also allows the definition Strings, which are represented by surrounding text with double quotes. Strings, however, are not actually a data type. Although they can be initialized using the double quote syntax, the compiler converts the string into a list of characters at compile time. The use of the String notation is simply syntatic sugar for programmers. It also helps increase the readability of code. In the following example, the data is stored in the representation of str1: a list of characters. However, Haskell allows the definition of a string using double quotes, as seen in str2, which is much more understandable.

\begin{minted}{haskell}
let str1 = ['H','a','s','k','e','l','l','!']
let str2 = "Haskell!"
\end{minted}

In addition to these basic data types, Haskell also offers type variables. Type variables are variables whose type has not been explicitly declared; rather, they can be any type. By defining a function without declaring data types, the variables in the function can be used as any type and the function can be polymorphic. In the following example, the function can handle a list of any type because its uses a type variable. 

\begin{minted}{haskell}
lastTwo :: [a] -> [a]
lastTwo a = [a !! ((length a) - 2), a !! ((length a) - 1)]
\end{minted}

\subsubsection{Type Checking}
Type checking in Haskell is performed statically at compile time. Haskell uses type-declarations for functions, in which the types of parameters and return values are explicitly defined. Any use of a function in which parameters do not meet the defined function type is flagged by the compiler, and compilation will be aborted. In addition, ues type inferencing by context. The type system in Haskell deduces obvious types and makes them concrete. In the following example, although the type of myNum is unknown at compile time, the compiler infers that the Int type is desired because myNum is added to an Int. 

\begin{minted}{haskell}
let myStr = "2" 
let myNum2 = (read myStr) + 2
\end{minted}

If the context does not suggest the type, as in the example below, then an exception will result because the compiler cannot infer what the type is going to be and is unable to handle it. 

\begin{minted}{haskell}
let myStr = "2" 
let myNum = read myStr
\end{minted}

Haskell uses typeclasses to categorize the type system. Typeclasses define the behavior of a general type. A type must support the definition of its typeclass, but may also be more specific. For example, all of the operators in Haskell are categorized under the Eq typeclass. Other examples of typeclasses in Haskell include Ord, Show, Read, Enum, Num, Integral, and Floating. Typeclasses can be used to allow multiple types to be passed to a function. For example, to create a function that will accept both Int and Integer types, it's as simple as declaring its typeclass as Integral.

\subsection{Control Abstractions}
\subsubsection{Expressions}
\bi
    \item Function definitions
\begin{minted}{haskell}
greet :: String -> String
greet name = "Hello, " ++ name ++ "!"
\end{minted}
    \item Bindings: let/in (valid expression), where (locally bound to a syntactic construct)
\begin{minted}{haskell}
rectPrismVol :: (Num a) -> a -> a -> a -> a
rectPrismVol length width height = 4 * (faceArea length width)
    + 2 * (baseArea length height)
where   faceArea l w = l * w
        baseArea = l * h
\end{minted}
\begin{minted}{haskell}
myExp =
    let e = 2.7182
    in  e ** x
\end{minted}
NOTE: statements in let/in must be aligned in same column
\ei

\subsubsection{Operators and Precedence}
\bi
    \item Operators: postfix notation, naming typically consists of symbols
    \item Functions: infix notation, named using alphanumeric characters in camel case
    \item Any function can be used as an operator by calling it in postfix notation
\begin{minted}{haskell}
f :: (Int a) => a -> a -> a
f a b = a + b
; invoke the function in postfix notation
print (1 `f` 2)
\end{minted}
    \item Any operator can be called as a function in infix notation
\begin{minted}{haskell}
print ((+) 2 5)
\end{minted}
    \item Operators can be overloaded
\begin{minted}{haskell}
(*) :: (Num a) => a -> a -> a
(*) a b = a * a * b
print (2 * 3)
\end{minted}
\ei

\subsubsection{Selection Constructs}
\bi
    \item Pattern matching
\begin{minted}{haskell}
favoriteLang :: String -> String
favoriteLang "Haskell" = "You have refined taste, my friend."
favoriteLang "Clojure" = 
    "The wise do not build a house on unsturdy ground."
favoriteLang lang = lang ++ 
    " is a fine choice, but you should give Haskell a spin."
\end{minted}
    \item if/then/else
\begin{minted}{haskell}
guessGame :: Int -> String
guessGame x = if x == 42
    then "You have a deep understanding of life."
    else "You need to think more about life."
\end{minted}
    \item Guards
\begin{minted}{haskell}
let balance = 200
assessWorth :: Int -> String
assessWorth =
    | balance >= 100000 = "You're rich!"
    | balance >= 100 = "You're rich by student standards!"
    | otherwise = "Need a loan, friend?"
\end{minted}
    \item Case expression
\begin{minted}{haskell}
favoriteMathSymbol :: String -> String
favoriteMathSymbol x = case x of
    "Pi" -> "Geometry is your mind's eye."
    "e" -> "May the calculus forever be with you."
    "Epsilon" -> "I think I am within the limit, "
        ++ "therefore, I am within the limit."
    x = "You have much to learn of the maths."
\end{minted}
\ei

\subsubsection{Iterative Constructs}
\bi
    \item List comprehensions
\begin{minted}{haskell}
filterModThree :: [Int] -> [Int]
filterModThree xs = [x | x <- xs, x `mod` 3 == 0]
\end{minted}
    \item Map/fold
    \item Recursion
\ei

\subsubsection{Functions}
\bi
    \item Definition/use
    \item Parameter passing techniques
\ei

\subsubsection{Scoping}
\bi
    \item Static
\ei

\subsubsection{Modules}
\begin{minted}{haskell}
module addNums
( addTwo
, addThree
, addFour
) where

addTwo :: (Num a) => a -> a
addTwo x = x + 2

addThree :: (Num a) => a -> a
addThree x = x + 3

addFour :: (Num a) => a -> a
addFour x = x + 4
\end{minted}
\subsubsection{Exception Handling}


\section{Advanced Topics}

\subsection{Inheritance}
\subsection{Concurrency Support}
\subsection{Introspection}

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
