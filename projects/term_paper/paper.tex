% Author: Kurt O'Hearn
% Author: Nicholas Olesak
% Date: April 15, 2013
% Class: CIS 343-02
% Purpose: Progamming Language Survey Term Paper on Haskell
\documentclass[titlepage,12pt]{article}

\usepackage{minted}

% aliases
\newcommand{\be}{\begin{enumerate}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\ei}{\end{itemize}}

\title{Programming Language Survey Paper on Haskell}
\author{
        Kurt O'Hearn\\
        Nicholas Olesak\\
}
\date{\today}


\begin{document}

\maketitle 
\setcounter{tocdepth}{3}
\tableofcontents \newpage

\section{Introduction}
This paper provides an overview of the Haskell programming language.

\subsection{Origin and History}

In the early 1930s, Alonzo Church formulated a mathematical abstraction known as lambda calculus, which involves the description and evaluation of functions in mathematics (Haskell). Lambda calculus became the foundation for functional programming (``Haskell''). However, as numerous functional languages began to develop, all of which were similar in expressiveness and semantics, there became the need for a standard functional language to aid the spread of functional programming (Hudak 1). A meeting was held in 1987 at a Functional Programming Languages and Computer Architecture conference to address this need (Hudak 1). The meeting resulted in the formation of a committee to design a standard functional language. In 1990, the committee produced their result: a consolidation of existing functional programming languages into an open standard, common language to be used for functional programming research: Haskell (Hudak 3).

Haskell is named after Haskell Curry, a logician whose work greatly contributed to functional programming. It has a lambda as its logo to symbolize lambda calculus as its foundation. Today, Haskell is widely used in many different aspects of computing. From AT\&T's automated processing of abuse complaints in its network security division to the National Radio Astronomy Observatoryâ€™s implementation of core science algorithms, Haskell can be found in many aspects of modern industry (``Haskell''). 

\subsection{Functional Programming Paradigm}

Haskell is a pure functional language, which means that its functions cannot change values, but rather only accept and return values. Each functions acts independently of other functions, and does not change the state of anything outside of its scope. This is referred to as having no ``side-effects,'' and it allows Haskell to be exceptionally optimized and permit parallel processing. In addition, functions do not have to be declared in a particular order since they all exist independently of one another. 

In addition, it is also a lazy language; expressions in Haskell are not evaluated at binding time, but rather are evaluated only when the result is needed. 

Type checking in Haskell is static and is performed at compile time. Haskell uses type-declarations for functions, in which the types of parameters and return values are explicitly defined. Any use of a function in which parameters do not meet the defined function type is flagged by the compiler, and compilation will be aborted. For example, the following function defines 

\subsection{Application Domains}



[TODO]~\cite{learnyouahaskell}
\begin{minted}{haskell}
module Main where
import Data.List

main :: IO ()
main = putStrLn "Hello World!" >> test

test = do 
    print 123
\end{minted}

\section{Data and Control Abstractions}


\subsection{Data Abstractions}
\subsubsection{Data Types}
\bi
    \item Basis data types: Int, Float, Char, Boolean, lists, tuples
\begin{minted}{haskell}
let i = 2
let x = 3.14
let c = 'c'
let str = ['H','a','s','k','e','l','l','!']
; shorthand for the above
let str2 = "Haskell!"
let t = (3.14, 'pi')
\end{minted}

    \item Type variables: variables that can be any type (used in polymorphic functions)
\begin{minted}{haskell}
lastTwo :: [a] -> [a]
lastTwo a = [a !! ((length a) - 2), a !! ((length a) - 1)]
\end{minted}
\ei

\subsubsection{Type Checking}
\bi
    \item Haskell: static typing, type inferencing by context
\begin{minted}{haskell}
let myStr = "2"
; will result in an exception as the desired type to convert to is
; ambiguous since Haskell has no context to infer the type
let myNum = read myStr
; not ambiguous, as the compiler infers the Int type is desired
let myNum2 = (read myStr) + 2
\end{minted}
    \item Type classes: Eq, Ord, Show/Read, Bounded, Enum, Num/Integral/Floating
\ei

\subsection{Control Abstractions}
\subsubsection{Expressions}
\bi
    \item Function definitions
\begin{minted}{haskell}
greet :: String -> String
greet name = "Hello, " ++ name ++ "!"
\end{minted}
    \item Bindings: let/in (valid expression), where (locally bound to a syntactic construct)
\begin{minted}{haskell}
rectPrismVol :: (Num a) -> a -> a -> a -> a
rectPrismVol length width height = 4 * (faceArea length width)
    + 2 * (baseArea length height)
where   faceArea l w = l * w
        baseArea = l * h
\end{minted}
\begin{minted}{haskell}
myExp =
    let e = 2.7182
    in  e ** x
\end{minted}
NOTE: statements in let/in must be aligned in same column
\ei

\subsubsection{Operators and Precedence}
\bi
    \item Operators: postfix notation, naming typically consists of symbols
    \item Functions: infix notation, named using alphanumeric characters in camel case
    \item Any function can be used as an operator by calling it in postfix notation
\begin{minted}{haskell}
f :: (Int a) => a -> a -> a
f a b = a + b
; invoke the function in postfix notation
print (1 `f` 2)
\end{minted}
    \item Any operator can be called as a function in infix notation
\begin{minted}{haskell}
print ((+) 2 5)
\end{minted}
    \item Operators can be overloaded
\begin{minted}{haskell}
(*) :: (Num a) => a -> a -> a
(*) a b = a * a * b
print (2 * 3)
\end{minted}
\ei

\subsubsection{Selection Constructs}
\bi
    \item Pattern matching
\begin{minted}{haskell}
favoriteLang :: String -> String
favoriteLang "Haskell" = "You have refined taste, my friend."
favoriteLang "Clojure" = 
    "The wise do not build a house on unsturdy ground."
favoriteLang lang = lang ++ 
    " is a fine choice, but you should give Haskell a spin."
\end{minted}
    \item if/then/else
\begin{minted}{haskell}
guessGame :: Int -> String
guessGame x = if x == 42
    then "You have a deep understanding of life."
    else "You need to think more about life."
\end{minted}
    \item Guards
\begin{minted}{haskell}
let balance = 200
assessWorth :: Int -> String
assessWorth =
    | balance >= 100000 = "You're rich!"
    | balance >= 100 = "You're rich by student standards!"
    | otherwise = "Need a loan, friend?"
\end{minted}
    \item Case expression
\begin{minted}{haskell}
favoriteMathSymbol :: String -> String
favoriteMathSymbol x = case x of
    "Pi" -> "Geometry is your mind's eye."
    "e" -> "May the calculus forever be with you."
    "Epsilon" -> "I think I am within the limit, "
        ++ "therefore, I am within the limit."
    x = "You have much to learn of the maths."
\end{minted}
\ei

\subsubsection{Iterative Constructs}
\bi
    \item List comprehensions
\begin{minted}{haskell}
filterModThree :: [Int] -> [Int]
filterModThree xs = [x | x <- xs, x `mod` 3 == 0]
\end{minted}
    \item Map/fold
    \item Recursion
\ei

\subsubsection{Functions}
\bi
    \item Definition/use
    \item Parameter passing techniques
\ei

\subsubsection{Scoping}
\bi
    \item Static
\ei

\subsubsection{Modules}

\subsubsection{Exception Handling}


\section{Advanced Topics}

\subsection{Inheritance}
\subsection{Concurrency Support}
\subsection{Introspection}

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
